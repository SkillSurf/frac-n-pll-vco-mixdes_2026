// --------------------------------------------------------
// SECTION 1: MANUAL DEFINITIONS 
// --------------------------------------------------------
nature Voltage
    units = "V";
    access = V;
    idt_nature = Flux;
endnature

nature Flux
    units = "Wb";
    access = Phi;
endnature

nature Current
    units = "A";
    access = I;
    idt_nature = Charge;
endnature

nature Charge
    units = "c";
    access = Q;
endnature

discipline electrical
    potential Voltage;
    flow Current;
enddiscipline

// --------------------------------------------------------
// SECTION 2: OPENVAF COMPATIBLE MODULE
// --------------------------------------------------------

module freq_div(vout, vin);
    output electrical vout;
    input electrical vin;

    // Internal Memory Nodes (Voltage acts as storage)
    electrical n_count;      // Stores the current count (0V, 1V, 2V...)
    electrical n_last_clk;   // Stores the previous input state (0V or 1V)

    // Parameters
    parameter integer ratio = 24;
    parameter real vth = 0.8;
    parameter real vh = 1.2;
    parameter real vl = 0.0;
    parameter real tr = 1.0e-12; // Time constant for output
    parameter real mem_tr = 1.0e-14; // Time constant for internal memory

    // Variables
    real current_count_v;
    real next_count_val;
    real input_now_high;
    real input_prev_high;
    real output_target;
    integer rounded_count;

    analog begin
        // ------------------------------------------------
        // 1. READ MEMORY & INPUTS
        // ------------------------------------------------
        // Get current voltages
        current_count_v = V(n_count);
        
        // Convert real voltage to integer for logic (Rounding)
        rounded_count = current_count_v;

        // check if input is high NOW
        input_now_high = (V(vin) > vth) ? 1.0 : 0.0;
        
        // check if input WAS high (from delayed internal node)
        input_prev_high = (V(n_last_clk) > 0.3) ? 1.0 : 0.0;

        // ------------------------------------------------
        // 2. LOGIC (Manual Edge Detection)
        // ------------------------------------------------
        // Default: hold the current value
        next_count_val = rounded_count;

        // Rising Edge: Input is high, but the memory of the last clock is still low
        if (input_now_high > 0.5 && input_prev_high < 0.5) begin
            next_count_val = rounded_count + 1.0;
            
            if (next_count_val >= ratio) begin
                next_count_val = 0.0;
            end
        end

        // ------------------------------------------------
        // 3. WRITE MEMORY (Replacing 'transition')
        // ------------------------------------------------
        // We use a manual RC equation: I = C*dV/dt + (V - Target)/R
        // This forces the node to smoothly transition to 'next_count_val'
        // We set R=1, C=mem_tr.
        
        // Update Count Memory
        I(n_count) <+ mem_tr * ddt(V(n_count)) + (V(n_count) - next_count_val);

        // Update Last-Clock Memory (This creates the delay needed for edge detection)
        I(n_last_clk) <+ mem_tr * ddt(V(n_last_clk)) + (V(n_last_clk) - input_now_high);

        // ------------------------------------------------
        // 4. OUTPUT GENERATION
        // ------------------------------------------------
        if (next_count_val < (ratio / 2.0)) begin
            output_target = vh;
        end else begin
            output_target = vl;
        end
        //output_target = next_count_val;

        // Output Filter
        I(vout) <+ tr * ddt(V(vout)) + (V(vout) - output_target);
    end

endmodule